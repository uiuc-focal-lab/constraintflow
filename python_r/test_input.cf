def Shape as (Float l, Float u, PolyExp L, PolyExp U){(curr[l]<=curr) and (curr[L]<=curr) and (curr[u]>=curr) and (curr[U]>=curr)};

func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func replace_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[L]) : (coeff * n[U]);
func replace_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[U]) : (coeff * n[L]); 

func priority1(Neuron n) = -n[layer];
func priority2(Neuron n) = n[layer];

func backsubs_lower(PolyExp e, Neuron n) = (e.traverse(backward, priority1, true, replace_lower){e<=n}).map(simplify_lower);
func backsubs_upper(PolyExp e, Neuron n) = (e.traverse(backward, priority1, true, replace_upper){e>=n}).map(simplify_upper);

func f(Neuron n1, Neuron n2) = (n1[l] >= n2[u]);
func f2(Neuron n1, Neuron n2) = (n1[l] >= n2[l]);

transformer deeppoly(curr, prev){
    Relu -> min(sum(prev[l]), 0) == 0 ? (sum(prev[l]), sum(prev[u]), sum(prev[L]), sum(prev[U])) : (sum(prev[u])<=0 ? (0,0,0,0) : (0, sum(prev[u]), 0, (sum(prev[u]) / (sum(prev[u]) - sum(prev[l]))) * sum(prev) - (sum(prev[u])*sum(prev[l]) / (sum(prev[u]) - sum(prev[l])))));
    Affine -> (backsubs_lower(prev.dot(curr[weight]) + curr[bias], curr), backsubs_upper(prev.dot(curr[weight]) + curr[bias], curr), prev.dot(curr[weight]) + curr[bias], prev.dot(curr[weight]) + curr[bias]);
    Maxpool -> len(argmax(prev, f)) > 0 ? (max(prev[l]), max(prev[u]), avg((argmax(prev, f))[L]), avg((argmax(prev, f))[U])) : (max(prev[l]), max(prev[u]), max(prev[l]), max(prev[u]));
}

flow(forward, priority2, true, deeppoly);