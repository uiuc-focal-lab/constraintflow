def Shape as (Float l, Float u){(curr[l]<=curr) and (curr[u]>=curr)};

func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func priority(Neuron n) = n[layer];

transformer ibp(curr, prev, curr_list){
    rev_Relu -> ( sum(prev[l]) > 0 ? max(sum(prev[l]), curr[l])  : curr[l]), (min(sum(prev[u]), curr[u]));
    rev_Maxpool -> ((( (sum(prev[l]) > 0) and (sum(prev[l]) > max(curr_list[u]))) or (curr[l] >= max(curr_list[u]))) ? max(curr[l], sum(prev[l])) : curr[l]) , min(curr[u], sum(prev[u]));
}

flow(backward, priority, true, ibp);