def Shape as (Float l, Float u, PolyExp L, PolyExp U){[(curr[l]<=curr),(curr[u]>=curr), (curr[L]<=curr),(curr[U]>= curr)]};

func priority(Neuron n) = n[layer];

func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func simplify_lower_list(PolyExp e) = e.map(simplify_lower);
func simplify_upper_list(PolyExp e) = e.map(simplify_upper);

func replace_lower(Neuron n, Float c) = c >= 0? c*n[L] : c*n[U];
func replace_upper(Neuron n, Float c) = c >= 0? c*n[U] : c*n[L];

func forward_subs_lower(Neuron n, PolyExp e) = (e.traverse(forward, priority, true, replace_lower){e <= n}).map(simplify_lower);
func forward_subs_upper(Neuron n, PolyExp e) = (e.traverse(forward, priority, true, replace_upper){e >= n}).map(simplify_upper);

func create_c(Neuron n, PolyExp e) = n == e;

transformer ibp(curr, prev, curr_list){
    rev_Affine -> (lp(minimize, curr, (curr[equations].map_list(create_c curr))), lp(minimize, curr, (curr[equations].map_list(create_c curr))), curr[L], curr[U]);
}

flow(backward, priority, true, ibp);