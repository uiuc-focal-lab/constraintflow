def Shape as (Float l, Float u, PolyExp L, PolyExp U){(curr[l]<=curr) and (curr[L]<=curr) and (curr[u]>=curr) and (curr[U]>=curr)};

func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func replace_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[L]) : (coeff * n[U]);
func replace_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[U]) : (coeff * n[L]); 

func priority1(Neuron n) = -n[layer];
func priority2(Neuron n) = n[layer];

func backsubs_lower(PolyExp e, Neuron n) = (e.traverse(backward, priority1, true, replace_lower){e<=n}).map(simplify_lower);
func backsubs_upper(PolyExp e, Neuron n) = (e.traverse(backward, priority1, true, replace_upper){e>=n}).map(simplify_upper);

transformer deeppoly(curr, prev){
    Relu -> sum(prev[l])>=0 ? (sum(prev[l]), sum(prev[u]), sum(prev[L]), sum(prev[U])) : (sum(prev[u])<=0 ? (0,0,0,0) : (0, sum(prev[u]), 0, (sum(prev[u]) / (sum(prev[u]) - sum(prev[l]))) * sum(prev) - sum(prev[u])*sum(prev[l]) / (sum(prev[u]) - sum(prev[l]))));
}

flow(forward, priority2, true, deeppoly);